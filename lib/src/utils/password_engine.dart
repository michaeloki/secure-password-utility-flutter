import '../constants.dart';
import 'file_reader.dart';
import 'dart:math';

Future<bool> weakPasswordChecker(String rawPassword, int passwordLength) async {
  var status = true;
  try {
    if (rawPassword.isEmpty || passwordLength == 0) {
      print('SecurePasswordUtility::: empty password and/or zero length is not allowed');
      return !status;
    } else {
      try {
        if (!(passwordLength == rawPassword.length && passwordLength >= 10)) {
          print('SecurePasswordUtility::: password length is too short');
          return !status;
        } else {
          if(findWeakPasswords(rawPassword)) {
            status = false;
          }

          if (status) {
            var pattern = RegExp(
                '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[-+_!@#\$%^&*.,?]).+\$'
            );
            if(pattern.firstMatch(rawPassword) != null) {
              // print('SecurePasswordUtility:::Strong password:::: ${pattern.firstMatch(rawPassword)![0]}');
              return status;
            } else {
              return !status;
            }
          }
          return status;
        }
      } catch(firstException) {
        print('SecurePasswordUtility:::firstException $firstException');
      }
    }
  } catch(secondException) {
    print('SecurePasswordUtility::: $secondException');
  }
  return status;
}
Future<String> strongPasswordGenerator(int passwordLength) async {
  var uCaseLength = 0;
  var lCaseLength = 0;
  var nCaseLength = 0;
  var cCaseLength = 0;
  var remainder = 0;
  var autoGeneratedPassword = '';
  var upperCaseGenerator = '';
  var lowerCaseGenerator = '';
  var numericGenerator = '';
  var characterGenerator = '';
  var scrambledPassword = '';
  var optionalCharacter = '';

  if (passwordLength <= 11) {
    return 'Invalid input';
  }
  if ((passwordLength % 4 != 0)) {
remainder = passwordLength % 4;
uCaseLength = ((passwordLength - remainder) / 4).round();
lCaseLength = ((passwordLength - remainder) / 4).round();
nCaseLength = ((passwordLength - remainder) / 4).round();
cCaseLength = ((passwordLength - remainder) / 4).round();
} else {
uCaseLength = (passwordLength / 4).round();
lCaseLength = (passwordLength / 4).round();
nCaseLength = (passwordLength / 4).round();
cCaseLength = (passwordLength / 4).round();
}

for (var i = 0; i < uCaseLength; i++) {
upperCaseGenerator += upperCase[Random().nextInt(upperCase.length)];
}


  for (var j = 0; j < lCaseLength; j++) {
    lowerCaseGenerator += lowerCase[Random().nextInt(lowerCase.length)];
  }

for (var k = 0; k < nCaseLength; k++) {
numericGenerator += allNumbers[(Random().nextInt(allNumbers.length))];
}
  for (var z = 0; z < cCaseLength; z++) {
    characterGenerator += allCharacters[(Random().nextInt(allCharacters.length))];
  }
  scrambledPassword = upperCaseGenerator + lowerCaseGenerator + numericGenerator + characterGenerator;

  if (remainder != 0) {
    for (var x = 0; x < remainder; x++) {
      optionalCharacter += allCharacters[(Random().nextInt(allCharacters.length))];
    }
    scrambledPassword = scrambledPassword.toString() + optionalCharacter;
    return completePasswordGeneration(passwordLength, autoGeneratedPassword, scrambledPassword);
  } else {
    return completePasswordGeneration(passwordLength, autoGeneratedPassword, scrambledPassword);
  }
}


String completePasswordGeneration (int passwordLength,autoGeneratedPassword, scrambledPassword) {
for (var b = 0; b < passwordLength; b++) {
autoGeneratedPassword += scrambledPassword[Random().nextInt(scrambledPassword.length)];
}
return autoGeneratedPassword;
}

Future<String> createStrongPassword (int codeLength) async {
if (codeLength <= 11 || codeLength >= 50) {
return 'Invalid input';
}
var createNewPassword = strongPasswordGenerator(codeLength);
if (await weakPasswordChecker(createNewPassword.toString(), codeLength)) {
return createNewPassword;
} else {
createNewPassword = createStrongPassword(codeLength);
}
return createNewPassword;
}

String productKeyGenerator(int productKeyLength) {
  var generatedProductKey = '';
  var finalGeneratedProductKey = '';
  var modulusSum = 0;
    if(productKeyLength <=15) {
      print('SecurePasswordUtility::: The length of your product key must be greater than 15 and should be a multiple of 4 or 5 e.g. 16 or 20');
      return '';
    }
    if(!(productKeyLength%4 ==0 || productKeyLength%5 ==0 )) {
      print('SecurePasswordUtility::: The length of your product key must be greater than 15 and should be a multiple of 4 or 5 e.g. 16 or 20');
      return '';
    }
    if ((productKeyLength >= 16 &&
        productKeyLength <= 100) &&
        (productKeyLength % 4 == 0 || productKeyLength % 5 == 0)) {
      const alphaNumeric = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456890';
      for (var i = 0; i < productKeyLength; i++) {
        generatedProductKey += alphaNumeric[Random().nextInt(alphaNumeric.length)];
      }
      if ((productKeyLength % 5 == 0 && productKeyLength % 4 == 0) ||
          productKeyLength % 5 == 0) {
        for (var k = 0; k < productKeyLength; k++) {
          modulusSum = k + 1;
          if (modulusSum % 5 == 0) {
            finalGeneratedProductKey +=
                generatedProductKey.substring(k - 4, k + 1) + '-';
          }
        }
      }
      if (productKeyLength % 4 == 0 && productKeyLength % 5 != 0) {
        for (var l = 0; l < productKeyLength; l++) {
          modulusSum = l + 1;
          if (modulusSum % 4 == 0) {
            finalGeneratedProductKey +=
                generatedProductKey.substring(l - 3, l + 1) + '-';
          }
        }
      }
    }
    finalGeneratedProductKey = finalGeneratedProductKey.substring(
        0, finalGeneratedProductKey.length - 1);
  return finalGeneratedProductKey;
}
